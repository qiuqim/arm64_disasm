# ADRP指令
### 作用：
将当前指令所在页的基地址加/减去字节差，并写入目标寄存器
        字节差：与目标地址页基地址的间隔字节数，其为PAGE_SIZE的整数倍
        此时的字节差就是指令所操作的立即数
该指令通常配合add指令来向目标寄存器写入完整的地址
        最后通过br、blr实现长跳转

### 字节码拆分：

- `0x90 0xFF 0xFF 0xE1`

- `1001 0000 1111 1111 1111 1111 1110 0001`

  - 对照表

  ```smalltalk
     1    00      10000  1111 1111 1111 1111 111   00001
    |31| 30-29  | 28-24 | 23-5                    | 4-0 |
    |sf| immlo  |       | immhi                   | rd  |
  ```

  - 寄存器位 4-0
    - `0 0001` -> rd 表示x1寄存器
    - 如果是 `0 0000` -> 则表示x0寄存器
    - 以此类推
      - `0 0010` -> x2
      - `0 0011` -> x3
      - `. ....` -> x...
  - 立即数位（高19位） 23-5
    \- `1111 1111 1111 1111 111`
  - adr指令位 28-24
    - `10000`
    - 至于为什么是adr指令位而不是adrp指令位，是因为我发现两者是相同的
    - adr与adrp的差异在于第31位是否为1
  - 立即数位（低2位） 30-29
    - `00`
  - 64位操作位 31
    - `1`
    - 当该位为1时表示adrp指令，当为0时表示adr指令

  ## armv8 手册中

  - `SignExtend(immhi:immlo:Zeros(12), 64);`
  - `有符号扩展（操作数高位：操作数低位：12个0，总长64位）`
  - 拼接结果
    - = `1111 1111 1111 1111 111 00 0000 0000 0000`
    - = `0x1 FFFF C000`
  - 符号扩展步骤及结果
    - = `0x1 FFFF C000 << 31 >>31`
    - = `0xFFFF FFFF FFFF C000`
    - = `-16384`
  - 也就是说，要在当前指令所在页基地址基础上减去16384字节
  - -16384/PAGE_SIZE = -4， 也就是4页的大小

- 那么该指令执行时就会进行以下步骤
  - 首先会获取当前指令所在地址
    - 注意其与b、bl等指令一致，获取的均是当前指令字节码的起始地址，非下条指令也非本指令末尾处
  - 将当前指令所在地址`&=~0xFFF`，以抹去低12位，得到指令所在页基地址
  - 将获取到的基地址减去16384，得到目标页基地址
  - 将目标页基地址写入指定的寄存器中

